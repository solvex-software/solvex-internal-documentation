# Blog Ideas

## Technical
- Structural Recursion
- Iteration Levels
- Pure Functions & Referential Transparency
- FP vs. OOP
- Algebras
- Combinators
- Writing Semantically Meaningful Code
- Maps vs. Functions
- Monad Comprehensions
- Why use abstractions/typeclasses?
    - Leads to less things to remember in the same language and with other languages
    - Allows you to start to see and understand more complex abstractions
    - Think more logically
    - Not always good (ie: Nothing to abstract, just one thing)
    - allows for easier property based testing
- Why use combinators?
    - We focus on functions
    - Basically pipes/railroads to how we want to process data
    - Elegant code that removes cruft and gets to the point
- Using the right type vs maybe for partial functions
    - good examples: triples and division with 0
- Using Unit, Void, Either, or Tuple are code smells
    - They are the fundamental building blocks of ADTs
    - Thus using ADTs is almost always a better choice
    - ADTs add clarity, pattern matching, type safety, etc...
    - Tuple/Either can be seen as anonymous Product/Sum Types
- The expression problem
- Unit testing is not enough
- Property based testing removes the need for code coverage and documents code with useful properties
- Removing uneccessary overhead
    - .gitignore
    - code coverage
    - CI/CD
- the problem with prototyping/argument for static typing/doing things ahead rather than later
- the problem with abusing typs (either/maybe)
- the problem with either/tuple/union/void
- ADTs are a semiring
- the benefit of standards/style guides/removing variables/overhead
    - Database creation/management/orm
    - dependencies
    - linter/formatter
    - config schemas
    - versioning
- Parametric vs Adhoc Polymorphism
- Properties
    - Associative
    - Commutative
    - Distributive over ...
    - Reflexive
    - Transitive
    - Identity
    - Symmetric
    - Inverse
    - Zero/One
    - Idempotent
    - Complement Law
    - Reversibility
    - Involution
    - Boundary Conditions
    - Monotonicity
    - Consistency
    - Conservation
- Data structure layer vs ADT layer(s) vs Domain Layer vs Frontend
- Static vs. Dynamic environment and closures
- Using accumulators/stack/laziness
- Choosing between different folds
- anatomy of a program (expression vs value), evaluation vs execution, interpreter vs transpiler vs compiler vs byte code
- data vs codata
- benefits of injective and bijective. you are either given what you want directly as an argument, you get it for free from a typeclass, or can convert to a type with the right typeclass
- lifting vs applying vs composing